# Ultralytics 🚀 AGPL-3.0 License - https://ultralytics.com/license
# YOLOv10m-memory-lite-opt object detection model for PCB data (2 classes, further optimized for memory)
# Model docs: https://docs.ultralytics.com/models/yolov10
# Task docs: https://docs.ultralytics.com/tasks/detect

nc: 2  # number of classes

# 스케일 값을 낮춰 전체 파라미터와 활성값(activation) 크기를 줄임
# [depth_scale, width_scale, max_channels]
scales:
  m: [0.5, 0.5, 512]  

# --- Further Simplified & Memory-Efficient Backbone ---
# 기존 모델 대비 각 Conv/C3k2 모듈의 반복 횟수를 1회로 유지하면서,
# 더 중요한 점은 깊은 레이어에서의 채널 수를 추가로 낮춰 메모리 사용량을 절감한 점입니다.
backbone:
  # [from, repeats, module, args]
  - [-1, 1, Conv, [32, 3, 2]]           # 0: P1/2; 원래 64 채널 → 64×0.5 = 32
  - [-1, 1, Conv, [64, 3, 2]]           # 1: P2/4; 원래 128 채널 → 128×0.5 = 64
  # layer 2: 원래 C3k2 모듈 256 채널 → 256×0.5 = 128, 여기서는 메모리 절감을 위해 128 대신 96 채널 사용
  - [-1, 1, C3k2, [96, False, 0.25]]    # 2: P2/4
  # layer 3: 원래 256 채널 → 128 채널로 축소
  - [-1, 1, Conv, [96, 3, 2]]           # 3: P3/8
  # layer 4: 원래 C3k2 모듈 512 채널 → 512×0.5 = 256, 여기서는 256 대신 160 채널 사용
  - [-1, 1, C3k2, [160, False, 0.25]]    # 4: P3/8
  # layer 5: 원래 512 채널 → 256 채널, 여기서는 160 채널 사용
  - [-1, 1, Conv, [160, 3, 2]]          # 5: P4/16
  # layer 6: 원래 C3k2 모듈 512 채널 → 256 채널, 여기서는 160 채널 사용
  - [-1, 1, C3k2, [160, True]]          # 6: P4/16
  # layer 7: 원래 1024 채널 → 1024×0.5 = 512, 여기서는 512 대신 320 채널 사용
  - [-1, 1, Conv, [320, 3, 2]]          # 7: P5/32
  # layer 8: 원래 C3k2 모듈 1024 채널 → 512 채널, 여기서는 320 채널 사용
  - [-1, 1, C3k2, [320, True]]          # 8: P5/32
  # layer 9: SPPF 모듈도 채널 수를 줄여 320 채널로 적용
  - [-1, 1, SPPF, [320, 5]]             # 9: SPPF (spatial pyramid pooling)
  # C2PSA 모듈은 단순 PCB 데이터에 과도한 복잡도를 주므로 제거함

# --- Further Simplified & Memory-Efficient Head ---
# 검출 헤드를 단일 스케일(주로 P3/P4)로 단순화하여 중간 피처 저장 및 연산을 줄였습니다.
head:
  # [from, repeats, module, args]
  # (10) SPPF 출력(채널 320)을 P4 해상도로 업샘플하여 활용
  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]         # 10: Upsample SPPF output
  # (11) 백본 layer 6 (P4, 채널 160)와 concat
  - [[10, 6], 1, Concat, [1]]                             # 11: Concat with backbone layer 6
  # (12) concat된 피처를 처리하는 C3k2 모듈: 채널 160
  - [-1, 1, C3k2, [160, False]]                            # 12: Process concatenated P4 features
  
  # (13) P4 피처를 P3 해상도로 업샘플
  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]            # 13: Upsample to P3 resolution
  # (14) 백본 layer 4 (P3, 채널 160 → 실제 backbone layer 4는 160)와 concat
  - [[13, 4], 1, Concat, [1]]                             # 14: Concat with backbone layer 4
  # (15) concat된 피처 처리: 채널 96 (더 작은 채널 수로 메모리 절감)
  - [-1, 1, C3k2, [96, False]]                             # 15: Process concatenated P3 features
  
  # (16) P3 branch를 downsample하여 P4 해상도로 맞춤 (채널 96)
  - [-1, 1, Conv, [96, 3, 2]]                             # 16: Downsample P3 branch to P4 resolution
  # (17) 다운샘플된 P3 피처와 P4 branch (layer 12, 채널 160)를 concat
  - [[16, 12], 1, Concat, [1]]                            # 17: Concat downsampled P3 branch with P4 branch
  # (18) 최종 피처 처리: 채널 160
  - [-1, 1, C3k2, [160, True]]                             # 18: Final feature processing
  # (19) 검출 레이어: 단일 스케일에서 2개 클래스 검
  - [-1, 2, C3k2, [512, False]] # 19 (P4/16-medium)출
  - [[18], 1, Detect, [nc]]                               # 19: Detect layer
