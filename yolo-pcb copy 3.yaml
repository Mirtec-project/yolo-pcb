# Ultralytics ğŸš€ AGPL-3.0 License - https://ultralytics.com/license
# YOLOv10m-memory-lite object detection model for PCB data (2 classes, simplified & memory efficient)
# Model docs: https://docs.ultralytics.com/models/yolov10
# Task docs: https://docs.ultralytics.com/tasks/detect

nc: 2  # number of classes

# ìŠ¤ì¼€ì¼ ê°’ì„ ë‚®ì¶°ì„œ ì „ì²´ íŒŒë¼ë¯¸í„°ì™€ ì¤‘ê°„ í™œì„±ê°’(activation) í¬ê¸°ë¥¼ ì¤„ì„
# [depth_scale, width_scale, max_channels]
scales:
  m: [0.5, 0.5, 512]  

# --- Simplified & Memory-Efficient Backbone ---
# ì›ë˜ ëª¨ë¸ ëŒ€ë¹„ ê° Conv ë° C3k2 ëª¨ë“ˆì˜ ë°˜ë³µ íšŸìˆ˜ë¥¼ 1íšŒë¡œ ì¤„ì´ê³ , 
# ë„ˆë¹„ ìŠ¤ì¼€ì¼ì„ 0.5ë¡œ ì ìš©í•˜ì—¬ ì±„ë„ ìˆ˜ë¥¼ ì ˆë°˜ìœ¼ë¡œ ì¤„ì˜€ìŠµë‹ˆë‹¤.
backbone:
  # [from, repeats, module, args]
  - [-1, 1, Conv, [32, 3, 2]]           # 0: P1/2; ì›ë˜ 64 â†’ 64Ã—0.5=32
  - [-1, 1, Conv, [64, 3, 2]]           # 1: P2/4; ì›ë˜ 128 â†’ 128Ã—0.5=64
  - [-1, 1, C3k2, [128, False, 0.25]]    # 2: P2/4; ì›ë˜ 256, ë°˜ë³µ 2â†’1, 256Ã—0.5=128
  - [-1, 1, Conv, [128, 3, 2]]          # 3: P3/8; ì›ë˜ 256 â†’ 256Ã—0.5=128
  - [-1, 1, C3k2, [256, False, 0.25]]    # 4: P3/8; ì›ë˜ 512, ë°˜ë³µ 2â†’1, 512Ã—0.5=256
  - [-1, 1, Conv, [256, 3, 2]]          # 5: P4/16; ì›ë˜ 512 â†’ 512Ã—0.5=256
  - [-1, 1, C3k2, [256, True]]          # 6: P4/16; ì›ë˜ 512, ë°˜ë³µ 2â†’1, 512Ã—0.5=256
  - [-1, 1, Conv, [512, 3, 2]]          # 7: P5/32; ì›ë˜ 1024 â†’ 1024Ã—0.5=512
  - [-1, 1, C3k2, [512, True]]          # 8: P5/32; ì›ë˜ 1024, ë°˜ë³µ 2â†’1, 1024Ã—0.5=512
  - [-1, 1, SPPF, [512, 5]]             # 9: SPPF (spatial pyramid pooling)
  - [-1, 2, C3k2, [512, False]] # 19 (P4/16-medium)
  # C2PSA ëª¨ë“ˆì€ ë‹¨ìˆœ PCB ë°ì´í„°ì— ê³¼ë„í•œ ë³µì¡ë„ë¥¼ ì£¼ë¯€ë¡œ ì œê±°í•¨

# --- Simplified & Memory-Efficient Head ---
# ê²€ì¶œ í—¤ë“œë¥¼ ë‹¨ìˆœí™”í•˜ì—¬ ì¤‘ê°„ í”¼ì²˜ë§µì„ ì—¬ëŸ¬ ë²ˆ ì €ì¥í•˜ëŠ” ê²ƒì„ ì¤„ì´ê³ , 
# ë‘ ê°œì˜ ìŠ¤ì¼€ì¼(P3ì™€ P4 ì •ë„)ë§Œ ì‚¬ìš©í•˜ì—¬ ë©”ëª¨ë¦¬ ë¶€ë‹´ì„ ë‚®ì·„ìŠµë‹ˆë‹¤.
  - [-1, 2, C3k2, [512, False]] # 19 (P4/16-medium)
head:
  # [from, repeats, module, args]
  # [10] : upsample SPPF (layer 9) to P4 resolution
  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]         # 10: Upsample SPPF output
  - [[10, 6], 1, Concat, [1]]                             # 11: Concat with backbone layer 6 (P4 scale)
  - [-1, 1, C3k2, [256, False]]                            # 12: Process concatenated P4 features
  
  # P3 branch: upsample (from layer 12) to finer resolution and fuse with backbone P3 feature
  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]            # 13: Upsample P4 branch to P3 resolution
  - [[13, 4], 1, Concat, [1]]                             # 14: Concat with backbone layer 4 (P3 scale)
  - [-1, 1, C3k2, [128, False]]                            # 15: Process concatenated P3 features
  
  # ë‘ ìŠ¤ì¼€ì¼(P3ì™€ P4)ì—ì„œ ë‚˜ì˜¨ í”¼ì²˜ë¥¼ ë‹¤ì‹œ downsampleí•˜ì—¬ í•˜ë‚˜ì˜ ê²€ì¶œ í”¼ì²˜ë¡œ ê²°í•©
  - [-1, 1, Conv, [128, 3, 2]]                             # 16: Downsample P3 branch to P4 resolution
  - [[16, 12], 1, Concat, [1]]                            # 17: Concat downsampled P3 branch with P4 branch (from layer 12)
  - [-1, 1, C3k2, [256, True]]                             # 18: ìµœì¢… í”¼ì²˜ ì²˜ë¦¬
  - [[18], 1, Detect, [nc]]                               # 19: Detect layer (ë‹¨ì¼ ìŠ¤ì¼€ì¼ ê²€ì¶œ)
